{"meta":{"title":"Phạm Tuấn Anh","subtitle":"","description":"","author":"Phạm Tuấn Anh","url":"https://phamtuananh1996.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-05-27T10:47:44.404Z","updated":"2020-05-27T10:47:44.404Z","comments":false,"path":"/404.html","permalink":"https://phamtuananh1996.github.io/404.html","excerpt":"","text":""},{"title":"About","date":"2020-05-27T10:49:56.504Z","updated":"2020-05-27T10:49:56.504Z","comments":false,"path":"about/index.html","permalink":"https://phamtuananh1996.github.io/about/index.html","excerpt":"","text":"About"},{"title":"Book","date":"2020-05-27T11:21:04.466Z","updated":"2020-05-27T11:21:04.466Z","comments":false,"path":"books/index.html","permalink":"https://phamtuananh1996.github.io/books/index.html","excerpt":"","text":""},{"title":"Category","date":"2020-05-27T10:45:47.876Z","updated":"2020-05-27T10:45:47.876Z","comments":false,"path":"categories/index.html","permalink":"https://phamtuananh1996.github.io/categories/index.html","excerpt":"","text":""},{"title":"Links","date":"2020-05-27T10:49:09.136Z","updated":"2020-05-27T10:49:09.136Z","comments":true,"path":"links/index.html","permalink":"https://phamtuananh1996.github.io/links/index.html","excerpt":"","text":""},{"title":"Tags","date":"2020-05-27T10:46:21.128Z","updated":"2020-05-27T10:46:21.128Z","comments":false,"path":"tags/index.html","permalink":"https://phamtuananh1996.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Xây dựng một website cực nhanh với Hexo và github pages","slug":"xay-dung-mot-website-cuc-nhanh-voi-hexo-va-github-pages","date":"2020-06-01T08:26:57.000Z","updated":"2020-06-01T08:27:32.961Z","comments":true,"path":"2020/06/01/xay-dung-mot-website-cuc-nhanh-voi-hexo-va-github-pages/","link":"","permalink":"https://phamtuananh1996.github.io/2020/06/01/xay-dung-mot-website-cuc-nhanh-voi-hexo-va-github-pages/","excerpt":"","text":"Mở đầuBạn nghĩ sao về việc có 1 blog các nhân cho riêng mình. Vừa là nơi chia sẻ kiến thức của bản thân đồng thời cũng là 1 kênh để PR cho bản thân. Nhưng bạn lại không muốn mất quá nhiều thời gian để build lại blog từ đầu rồi là chọn công nghệ backend dùng gì fronend dùng gì. Rồi phải bỏ 1 số tiền cũng kha khá để thuê hosting với tên miền. Chưa kể đến là bạn không phải dân dev web thì sao? Với hexo và github pages sẽ giải quyết các vấn đề trên giúp bạn ! Hexo là gìHexo là một blog framework mạnh mẽ, nó tạo static web một cách đơn giản và nhanh chóng hoàn toàn bằng NodeJS. Bạn có thể viết bài bằng Markdown hoặc các markup languages khác. Bắt đầu ngay thôi nàoVới hexo thì rất đơn giản để có ngay 1 website tĩnh với các câu lệnh sau: 12345$ npm install hexo-cli -g$ hexo init blog$ cd blog$ npm install$ hexo server Vậy là xong tiếp theo là truy cập vào đường dẫn http://localhost:4000 và xem kết quả: Và done . Rất đơn giản phải không nào Tiếp theo là lên chọn 1 cái template thật lung linh , hexo cung cấp sẵn cho chúng khoảng 311 Themes tha hồ lựa chọn các bạn có thể xem qua ở đây: https://hexo.io/themes/ Mình chọn đại 1 theme và add vào website của mình: https://github.com/cofess/hexo-theme-pure Tiếp theo là clone về và để ở thư mục blog/themes/pure : 1git clone https:&#x2F;&#x2F;github.com&#x2F;cofess&#x2F;hexo-theme-pure.git themes&#x2F;pure và sửa file config blog/_config.yml : 1theme: pure Vậy là đã apply thành công theme mới rồi. thử xem kết quả xem sao: Vậy là thành công rồi! Để thêm 1 page hoặc 1 post chúng ta chạy câu lệnh sau : 1hexo new [layout] &lt;title&gt; Layout sẽ có dạng sau: Layout Path post source/_posts page source draft source/_drafts Mình sẽ thêm 1 bài post vào website với câu lệnh: 1hexo new post first_post Sau khi chạy lênh xong thì nó có tạo ra cho chúng ta 1 file ở đường dẫn \\blog\\source_posts\\first-post.md mở file này lên và viết nội dung thôi: 123456---title: First postdate: 2020-05-31 00:51:14tags: [&#39;post&#39;]---this is first post Lưu lại và run và kết quả : Có 1 bài xuất hiện rồi. giờ thì copy các bài đã viết từ viblo sang thôi và chỉnh sửa 1 số nội dung về profile ở trong file \\blog\\themes\\pure_config.yml Vậy là cũng có cái blog sương sương rồi. Các bạn hoàn toàn có thể tạo ra cá page khác nữa như page about ….. Deploy website lên github pagesViệc tạo Github Pages khá đơn giản, trước tiên bạn phải có một tại khoản Github, tạo mới một repo với name theo định dạng .github.io , vì username account github của mình là phamtuananh1996 nên mình sẽ tạo một repo với name là phamtuananh1996.github.io Khi đã tạo thành công Github Pages việc tiếp theo của chúng ta là sinh ra static web và deploy lên Github Pages để host. Khi đã deploy thì địa chỉ truy cập vào blog của bạn sẽ là: .github.io . Việc sinh ra static web và deploy trở nên khá đơn giản với Hexo chúng ta chỉ cần sửa file blog/_config.yml với nội dung như sau: 123deploy: type: git repo: https:&#x2F;&#x2F;github.com&#x2F;phamtuananh1996&#x2F;phamtuananh1996.github.io.git Thay username thành username của các bạn. Tiến hành cài thêm plugin hexo-deployer-git : 1$ npm install hexo-deployer-git -save Để deploy thì run 2 lệnh sau: 12$ hexo generate$ hexo deploy Và kết quả là đây: https://phamtuananh1996.github.io/ Vậy là xong ! Kết luận Chỉ chưa mất đến 5 phút là bạn đã có 1 blog hoàn chỉnh với hexo và github pages rồi. còn chần chờ gì nữa mà không khám phá hexo ngay. trên đây mình chỉ giới thiệu qua các chức năng cơn bản nhất thôi . Các bạn có thể tìm hiểu thêm ở https://hexo.io/ Chào ,Thân ái và quyêt thắng :heart_eyes::heart_eyes::heart_eyes::heart_eyes:","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://phamtuananh1996.github.io/tags/hexo/"}]},{"title":"Recommend(Laravel): Đặt tên sao cho chuẩn :))","slug":"recommendlaravel-dat-ten-sao-cho-chuan","date":"2020-05-26T01:49:28.618Z","updated":"2020-06-01T08:26:17.081Z","comments":true,"path":"2020/05/26/recommendlaravel-dat-ten-sao-cho-chuan/","link":"","permalink":"https://phamtuananh1996.github.io/2020/05/26/recommendlaravel-dat-ten-sao-cho-chuan/","excerpt":"","text":"Mở đầuHếy yoo, xin chào các bạn , trước kia hồi mới là sinh viên chưa bỏ được code cẩu thả đã nhảy vào code laravel ngay. Kết quả là mình đặt tên lớp, tên hàm, tên biến …. rất lung tung và không theo một quy tắc nhất định nào cả. Rồi đến lúc đọc lại code thì thôi rồi. nước mắt cứ phải gọi là tuôn rơi :sweat_smile::sweat_smile::sweat_smile: nghĩ lại vẫn thấy ngu rồi có khi định viết lại cả chức năng auth của nó ấy chứ. Vì vậy mình lên mạng tham khảo góp nhặt 1 số best practices về quy tắc đặt tên chung của laravel. Để các bạn cùng tìm hiểu. Ai biết rồi thì có thể lướt xuống và upvote ạ ai chưa biết có thể đọc để apply vào những dự án tiếp theo. Hoặc là dự án đang làm luôn (nhưng nếu cty có cách đặt tên riêng rồi thì lên theo qui tắc của cty nhé, không lại bị đuổi việc như chơi đấy) . :joy::joy::joy::joy: Conventions là gìThì conventions là tập hợp những nguyên tắc chung khi lập trình nhằm làm cho code dễ đọc, dễ hiểu, do đó dễ quản lý, bảo trì hơn.Cái này thì mỗi cty sẽ có quy định khác nhau nhưng đa phần sẽ theo các chuẩn PSR . PSR là viết tắt của PHP Standards Recommendations , là những tiêu chuẩn khi code PHP, nó được cộng đồng PHP xây dựng và áp dụng theo. Chuẩn PSR-0 nói về autoloading Chuẩn PSR-1 về basic coding Chuẩn PSR-2 về style coding Chuẩn PSR-3 nói về logging Chuẩn PSR-4 nói về autoloading : đây là phần cải tiến của PSR-0 Chuẩn PSR-7 nói về HTTP message Các bạn có thể tìm hiểu thêm về các chuẩn này. trên mạng có rất nhiều bài viết về chuẩn này. Ở khuôn khổ bài này thì sẽ có liên quan một chút ít về chuẩn PSR-2 về style coding Mà mình nói gì mà miên man vậy đang xem qua về một số best practices về quy tắc đặt tên của laravel mà. Let go nhé. Naming Conventions Sau đây là các quy ước đặt tên được chấp nhận và đang được sử dụng bởi cộng đồng người dùng Larave nhé! Không phải mình tự nghĩ ra đâu! ControllersLaravel dựa trên mô hình MVC mà. nên controller chúng ta sẽ thấy khá nhiều trong một project laravel vậy sao để đặt tên cho controller 1 cách xinh đẹp nhất. Ở đây thì người ta khuyến nghị: Tên controller phải bắt đầu bằng một danh từ Danh từ đó ở dạng số ít Theo sau đó là hậu tố “Controller” Tên Lớp trùng với tên file luôn nhé Ví dụ: Good 123class ArticleController extends Controller &#x2F;&#x2F;&#123; Bad 12class ArticlesController extends Controller &#123; 123class wp_articlesController extends Controller&#123; 123class Article extends Controller&#123; Bạn nên dùng Resource Controllers trừ khi có lý do cụ thể nào đó mà không thể làm như vậy Ví dụ: Good 12345678910class DomainController extends Controller&#123; public function index()&#123;&#125; // list domains public function create()&#123;&#125; // show create form public function store(Request $request)&#123; &#125; // handle the form POST public function show($id)&#123;&#125; // show a single domain public function edit($id)&#123;&#125; // show edit page public function update(Request $request, $id)&#123;&#125; // handle show edit page POST public function destroy($id)&#123;&#125; // delete a domain&#125; Bad 1234567class DomainController extends Controller&#123; public function list()&#123;&#125; // list domains public function create_or_save()&#123;&#125; // show create form then handle save public function show_edit($id)&#123;&#125; // show a single domain then show edit page public function delete($id)&#123;&#125; // delete a domain&#125; ModelsĐối với model thì cộng đồng khuyến nghị như sau: Chứ cái đầu tiên của class là chữ hoa Phải là danh từ dạng số ít Good 1234class Flight extends Model&#123; //&#125; Bad 12class Flights extends Model&#123; 12class flight extends Model&#123; Phương thức định nghĩa mối quan hệ (relationship methods) hasOne hoặc belongsTo phải là danh từ số ít Good 1234567class User extends Model&#123; public function phone() &#123; return $this-&gt;hasOne('App\\Phone'); &#125;&#125; Bad 1234567class User extends Model&#123; public function phones() &#123; return $this-&gt;hasOne('App\\Phone'); &#125;&#125; Các phương thức quan hệ khác (relationship methods) phải là dạng danh từ số nhiều Good 1234567class Post extends Model&#123; public function comments() &#123; return $this-&gt;hasMany('App\\Comment'); &#125;&#125; Bad 1234567class User extends Model&#123; public function comment() &#123; return $this-&gt;hasMany('App\\Comment'); &#125;&#125; Thuộc tính của model phải ở dạng snake_case Good 1$user-&gt;created_at Bad 1$user-&gt;createdAt Phương thức của model phải ở dạng camelCase Good 123456class User extends Model&#123; public function scopePopular($query) &#123; return $query-&gt;where('votes', '&gt;', 100); &#125; Bad 123456class User extends Model&#123; public function scope_popular($query) &#123; return $query-&gt;where('votes', '&gt;', 100); &#125; Functions Trong ưng dụng của chúng ta thì không thể thiểu các function do chúng ta tự viết ra nhằm trợ giúp một chức năng nào đó . Bạn nên tạo 1 file có tên helper.php Good 12project_folder/app/helper.phpproject_folder/app/Http/helper.php Bad 1project_folder/functions.php Bạn nên sử dụng autoloading của Composer để load các function của bạn Good 1234567// file composer.json...\"autoload\": &#123; \"files\": [ \"app/helpers.php\" ],... Bad 12345678// file app/Http/Controllers/HomeController.phpclass HomeController.php&#123; function index()&#123; require_once(app_path(\"helpers.php\")); &#125;&#125; Trước khi viết nõ hãy kiểm tra xem đã có đã tồn tại hay chưa băng cách Good 12345if (! function_exists('my_custom_helper')) &#123; function my_custom_helper($key, $default = null) &#123; // ... &#125;&#125; Bad 123function my_custom_helper($key, $default = null) &#123; // ...&#125; Khuyến nghị khác: Nếu function dài quá 25 dòng thì bạn nên tách nhỏ function đó thành những funtion nhỏ hơn. Mỗi function bạn nên viết Unit Test cho chúng để đảm bảo chúng chạy đúng Routes Router phải ở dạng số nhiều và các chữ cái đều là chữ thường . chỗ này mình cũng không biết giải thích như nào nhưng các bạn nhìn vào ví dụ nhé: Good 1Route::get('/users', 'UserController@index'); 1Route::resource('photos', 'PhotoController'); Bad 1Route::get('/user', 'UserController@index'); 1Route::get('/UsersList', 'UserController@index'); 1Route::resource('PHOTO', 'PhotoController'); Tên của router phải ở dạng snake_case Good 1Route::get('/user', 'UserController@active')-&gt;name('users.show_active'); Bad 1Route::get('/user', 'UserController@active')-&gt;name('users.show-active'); 1Route::get('/user', 'UserController@active')-&gt;name('show-active-users'); VariablesCái này hay gặp phải nhất này. Xem cộng đồng khuyến nghị gì về quy tắc đặt tên biến nhé ! Quy tắc chung của biến là ở dạng camelCase Good 1$articlesWithAuthor Bad 1$articles_with_author Tên của collection nên theo quy tắc Mô tả collection + danh từ sô nhiều Good 1$activeUsers = User::active()-&gt;get() Bad 123$users = User::active()-&gt;get()$user = User::active()-&gt;get()$User = User::active()-&gt;get() Tên 1 object nên theo quy tắc Mô tả collection + danh từ sô ít Good 1$activeUser = User::active()-&gt;first() Bad 1$users = User::active()-&gt;first() Views Mọi người rất hay lúng túng khi đặt tên cho view. thì tên view chúng ta nên đặt ở dạng snake_case Good 1show_filtered.blade.php Bad 1showFiltered.blade.php Gần đây cũng có khuyến nghị nên đặt tên view dạng kebab-case. bạn cũng có thể tham khảo cách này nhé! . Mình nghĩ cách này tốt hơn cách ở trên ! Good 1show-filtered.blade.php Bạn không nên sử lý logic code trong file view nhé mà hãy viết trong controller. trừ trường hợp bất khả kháng. ví dụ: Good 123456// $api_results is passed by controller&lt;ul&gt; @foreach($api_results as $result) &lt;li&gt;&#123;&#123; $result-&gt;name &#125;&#125;&lt;/li&gt; @endforeach&lt;/ul&gt; Bad 12345678@php $api_results = json_decode(file_get_contents(\"https://api.example.com\"));@endphp&lt;ul&gt; @foreach($api_results as $result) &lt;li&gt;&#123;&#123; $result-&gt;name &#125;&#125;&lt;/li&gt; @endforeach&lt;/ul&gt; Nếu đọc đến đây mà thấy mỏi mắt vì Good vs Bad quá thì clips lại mai đọc tiếp nhé !Database ConventionsTable and Fields Naming Tên Table phải là danh từ ở dạng số nhiều và phải dạng viết thường Good 12345class CreateFlightsTable extends Migration&#123; public function up() &#123; Schema::create('flights', function (Blueprint $table) &#123; Bad 12345class CreateFlightsTable extends Migration&#123; public function up() &#123; Schema::create('flight', function (Blueprint $table) &#123; 12345class CreateUsersTable extends Migration&#123; public function up() &#123; Schema::create('MyUsers', function (Blueprint $table) &#123; Tên bảng pivot phải dạng số ít của 2 model và được săp sếp theo alphabetical Good 123post_userarticle_userphoto_post Bad 123posts_usersuser_articlespost_photos Tên cột phải ở dạng snake_case và không lên có tên ở model Good 123usernametitlethumb_url Bad 1234UserName_titleThumbUrlpost_title Khóa ngoại phải ở dạng tên model + hậu tố _id Good 1user_id Bad 1234useridsiteidMemberidTransactionID Khóa chính phải là id. cái này hơi kỳ kỳ :joy::joy::joy:. dù gì đây cũng là khuyến nghị lên dùng Good 1id Bad 123IDpkidguid Database Alterations Tên file Migration phải theo pattern : yyyy_mm_dd_create_table Good 12019_06_06_164210_create_domains_table.php Bad 12019_06_06_164210_domains.php Tổng kết Bài viết cũng khá dài rồi. mặc dù còn rất nhiều recommend khác nhưng trên đây là nhưng cái các bạn hay dùng và hay gaejp nhất trong project của mình. hy vọng các bạn có thể tham khảo qua. và hãy comment xuống dưới recommend của bạn nhé Thân ái và quyết thắng :heart_eyes::heart_eyes::heart_eyes::heart_eyes::heart_eyes: Tham khảo: https://www.laravelbestpractices.com/","categories":[],"tags":[{"name":"laravel","slug":"laravel","permalink":"https://phamtuananh1996.github.io/tags/laravel/"}]},{"title":"Map, Filter, Reduce ... JavaScript","slug":"refactor-loai-bo-for-khoi-ung-dung-javascript-cua-ban","date":"2020-05-19T16:28:27.000Z","updated":"2020-06-01T08:24:20.046Z","comments":true,"path":"2020/05/19/refactor-loai-bo-for-khoi-ung-dung-javascript-cua-ban/","link":"","permalink":"https://phamtuananh1996.github.io/2020/05/19/refactor-loai-bo-for-khoi-ung-dung-javascript-cua-ban/","excerpt":"","text":"Mở đầuBài viết này mình nhắm tới những người mới bắt đầu với Javascript hoặc những người mới bắt đầu làm việc với Javascript . Nhằm giúp refactor lại code nếu bạn gặp 1 số trường hợp dưới đây. Và thông qua đó giúp các bạn hiêu hơn về higher-order functions như map, reduce, and filter ….. Tại sao lại sử dụng map, filter, reduce …. Nhìn code sẽ dễ đọc hơn rất nhiều Dễ hiểu hơn Dễ dàng debug Tránh thay đổi mảng ban đầu, do đó, giảm thiểu những rủi ro có thể xảy ra . Không cần quản lí vòng lặp Hãy nhớ rằng nó luôn được trả về trong callback1, Lặp qua tất cả các phần tử và nhận về 1 mảng đã sửa đổiĐôi khi chúng ta có một mảng các object muốn sửa đổi / thêm các thuộc tính của từng đối tượng , cụ thể giả sử chúng ta có thể có một mảng các string mà ta sẽ biến tất cả chúng thành chữ thường . Trên thực tế có thể có vô số tình huống ở đó Map sẽ giúp chúng ta xử lý 1 cách dễ dàng . Using for 12345var names = [\"Jack\", \"Jecci\", \"Ram\", \"Tom\"];var upperCaseNames = [];for(let i=0, totalNames = names.length; i&lt; totalNames ; i= i +1) &#123; upperCaseNames[i] = names[i].toUpperCase();&#125; Using map 12var names = [\"Jack\", \"Jecci\", \"Ram\", \"Tom\"];var upperCaseNames = names.map(name =&gt; name.toUpperCase()); Chú ý: Nếu bạn sử dụng map .Thì bạn sẽ không dùng được break, continue, return trong khi lặp . nếu muốn sử dụng chúng hãy dùng every hoặc some 2, Lặp qua tất cả các phần tử và thực hiện một hành độngUsing for 1234567function print(name) &#123; console.log(name);&#125;var names = [\"Jack\", \"Jecci\", \"Ram\", \"Tom\"];for(let i=0, totalNames = names.length; i&lt; totalNames ; i= i +1) &#123; print(names[i])&#125; Using forEach 12var names = [\"Jack\", \"Jecci\", \"Ram\", \"Tom\"];names.forEach(name=&gt; print(name)); 3, Lọc các phần tử của mảngTôi tin rằng trong quá trình bạn code bạn đã gặp tình huống phải lọc 1 số item ra khỏi mảng ban đầu . Ví dụ: bài toán lọc các phần tử chăn trong mảng dưới đây để làm được điều đó chúng ta phải xử lí khá rắc rối , nhưng với filter thì bạn có thể sử dụng nó 1 cách dễ dàng. Using for 1234567891011function isOdd(n) &#123; return n %2;&#125;var numbers = [1,2,3,4,5];var odd = [];for(let i=0, total = numbers.length; i&lt; total ; i= i +1) &#123; let number = numbers[i]; if( isOdd(number) ) &#123; odd.push(number); &#125;&#125; Using filter 12var numbers = [1,2,3,4,5, 6, 7]var odd = numbers.filter(n =&gt; n%2); // single line Bạn thấy đấy ngắn hơn raart nhiều phải không . 4, Tính toán các giá trị thành một giá trị duy nhấtVí dụ, với một dãy số bạn có thể dễ dàng tính được tổng của tất cả các giá trị. Using for 12345var numbers = [1,2,3,4,5]var result = 0;for(let i=0, total = numbers.length; i&lt; total ; i= i +1) &#123; result = result + numbers[i];&#125; Using reduce 123456var numbers = [1,2,3,4,5,6,7];function sum(accumulator, currentValue)&#123; return accumulator + currentValue;&#125;var initialVal = 0;var result = numbers.reduce(sum, initialVal); 5, Kiểm tra xem một mảng có chứa giá trị nào đó khôngĐôi khi bạn muốn kiểm tra 1 phần tử nào đó có tồn tại trong 1 array cho trước hay không. hãy nghĩ đến some Using for 1234567var names = [\"ram\", \"raj\", \"rahul\"];for(let i=0, totalNames = names.length; i&lt; totalNames ; i= i +1) &#123; if(names[i] === \"rahul\") &#123; console.log(\"%c found rahul\", \"color:red\"); return; &#125;&#125; Using some 12345var names = [\"ram\", \"raj\", \"rahul\"];let isRahulPresent = names.some(name =&gt; name===\"rahul\");if(isRahulPresent) &#123; console.log(\"%c found rahul\", \"color:red\"); &#125; 6, kiểm tra xem mọi phần tử trong một mảng có đáp ứng điều kiện khôngUsing for 123456var num = [1,2,3,4,5, 0];for(let i=0, total = numbers.length; i&lt; total ; i= i +1) &#123; if(num &lt;= 0) &#123; console.log(\"0 present in array\"); &#125;&#125; Using some 12345var num = [1,2,3,4,5, 0];var isZeroFree = num.every(e =&gt; e &gt; 0);if(!isZeroFree) &#123; console.log(\"0 present in array\");&#125; Kết luậnHy vọng qua bài viết này các bạn có thể tham khảo để refactor ứng dụng của mình 1 cách thông mình hơn. giúp cho code dễ đọc dễ hiểu và dễ maintain, debug hơn. :heart_eyes::heart_eyes::heart_eyes::heart_eyes::heart_eyes: Thanks for reading. I hope you upvote this.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://phamtuananh1996.github.io/tags/javascript/"}]},{"title":"Những chrome extension mà developer nên tham khảo","slug":"nhung-chrome-extension-ma-developer-nen-tham-khao","date":"2020-05-01T16:38:11.000Z","updated":"2020-05-27T05:52:24.034Z","comments":true,"path":"2020/05/01/nhung-chrome-extension-ma-developer-nen-tham-khao/","link":"","permalink":"https://phamtuananh1996.github.io/2020/05/01/nhung-chrome-extension-ma-developer-nen-tham-khao/","excerpt":"","text":"Mở đầuChào các viblo fan. Hôm này mình sẽ chia sẻ 10 extension mà mình hiện tại đang dùng các bạn có thể tham khảo nhé. hy vọng giúp ích được cho các dev nhà mình. Nếu bạn có extension hay và hữu ích thì đừng ngại ngần hãy comment ngay xuống dưới post này nhé. hoặc bạn hoàn toàn có thể viết tiếp phần 2 nhé ! Lét sờ tát :heart_eyes::heart_eyes::heart_eyes::heart_eyes::heart_eyes: 1, Vue.js devtoolsNếu bạn là một dev yêu thích và đang làm việc với vuejs thì các bạn đừng bỏ qua extension này nhé. Và được chính https://vuejs.org/ cung cấp nhé. bạn hoàn toàn có thể yên tâm và sử dụng. Vue.js devtools giúp bạn debugging ứng dụng vuejs của bạn một cách trực quan dễ hiểu Cho phép quản lý Component, vuex, events. routing ….. 2, React Developer ToolsCòn nếu bạn cũng yêu thích cả reactjs thì cũng có riêng 1 extension cho reactjs. Các bạn có thể tải về tại đây và do Facebook cung cấp vì thế các bạn cũng yên tâm sử dụng nhé. Giống như Vue.js devtools thì React Developer Tools giúp bạn debugging ứng dụng reactjs 3, Todoist for ChromeĐây là extension mình rất yêu thích vì nó giúp mình quản lý các task cần làm trong ngày mà không phải mở quá nhiều các ứng dụng quản lý khác. ngoài ra còn có thể lập lịch theo ngày nữa rất hưu ích phải không nào! Các bạn có thể thêm tiện ích tuyệt vời này vào trình duyệt tại đây 4, Json-viewerJson là 1 dạng dữ liệu quá quen thuộc với developer rồi nhỉ. Nhưng thật khó chịu khi mà mở trình duyệt lên https://viblo.asia/api/posts/newest?limit=20 mà trình duyệt lại trả về 1 đoạn json như này: Thì Json-viewer là 1 lựa chọn hoàn hảo để format đoạn json kia để dễ nhìn hơn như này: Nhìn đẹp hơn đúng không nào còn chần chờ gì nữa mà không thêm ngay cho trình duyệt của mình. 5, Medium-unlimitedMình hay lên đọc medium. Nhưng thỉnh thoảng thấy bài đang đọc hay thì Medium bắt nạp tiên để đọc bài hay gì gì ấy mà mình không đọc được nữa. Thì mình phát hiện ra tiện ích này Medium-unlimited có thể mở khóa bài viết trên Medium ấy . các bạn có thể tải về Tại đây 6, Viblo’s News FeedLà fan viblo mà chưa có extension này thì người ta cười cho ấy nhỉ. Các bạn thêm vào ngay đi nhé tại đây nè Extension giúp mình có được các bài viết mới nhất trên viblo cũng như không bỏ qua bất cứ thông báo nào của viblo. Rất hữu ích cho 5 sao. 7, Grammarly for ChromeĐây là 1 extension có mất phí và miễn phí giúp chúng ta sửa lỗi ngữ phát tiếng anh rất tiện và hữu ích cho tất cả mọi người không riêng gì dev đâu nhé. Thêm ngay tại đây 8, Lorem IpsumCái này thì đặc biệt hữu ích khi các bạn muốn test trường input mà “bầu bí” không biết ghi gì vào ô input thì extension là 1 lựa chọn cho bạn đấy! Chỉ cần vài thao tác là bạn đã có 1 đoạn văn bản đẹp để làm dữ liệu test rồi . 9, Google DịchÔi. cái tên nói lên tất cả rồi nhỉ Mình nghĩ các bạn đều có cả rồi nhỉ .nếu chưa có thì thêm ngay tại đây nhé 10, OctotreeNào các dân dev nhìn ảnh này là biết extension này là gì luôn nhé ! Nếu thấy hay và hưu ích thì tải ngay tại đây nhé https://www.octotree.io/ Kết luậnNhư mình đang PR cho các extension trên ấy các bác nhỉ. nhưng tin mình đi có những extension trên cũng đỡ vất vả được phần vào với công việc hiện tại của dev đấy. nếu có extension hay ho các bạn nhớ comment ở post này để mọi người tham khảo nhé.Nếu thấy hữu ích thì ngại gì mà không ấn thương thương nhỉ. :heart_eyes::heart_eyes::heart_eyes::heart_eyes: Thân ái và quyết thắng !!!!","categories":[],"tags":[{"name":"extension","slug":"extension","permalink":"https://phamtuananh1996.github.io/tags/extension/"}]},{"title":"Các trick search google mà developer nên biết","slug":"cac-trick-search-google-ma-developer-nen-biet","date":"2020-04-15T16:01:59.000Z","updated":"2020-05-27T05:53:00.198Z","comments":true,"path":"2020/04/15/cac-trick-search-google-ma-developer-nen-biet/","link":"","permalink":"https://phamtuananh1996.github.io/2020/04/15/cac-trick-search-google-ma-developer-nen-biet/","excerpt":"","text":"Mở đầuĐối với dân IT, kỹ năng tìm kiếm trên Google sẽ là “trợ thủ đắc lực” giúp bạn học tập và làm việc hiệu quả nhất. Bạn chỉ cần tập trung đọc hiểu, ghi nhớ, phân tích cốt lõi của một vấn đề, mọi thông tin còn lại đã có Google lo. Vậy làm sao để tìm kiếm trên Google và research paper hiệu quả nhất? Bài viết này sẽ giới thiệu 1 số mẹo thường dùng với google search đối với dev nhé. 1. Use an Exact Phrase Mô tả: Đây là cách tìm cụm từ chính xác bằng dấu ngoặc kép Syntax: “[keyword 1] [keyword 2]” [keyword 3] Ví dụ: Khi bạn tìm kiếm với từ khóa thuật toán sắp xếp nổi bọt và ngôn ngữ dùng là golang và bạn chỉ muốn kết quả trả về có chứa ngôn ngữ golang. bạn hãy thử: 2. Google Search Exclude Word Mô tả: Để có thể loại bỏ những từ tìm kiếm không quan trọng trong kết quả, bạn chỉ cần nhập dấu - đằng trước từ khóa mà bạn cần loại bỏ là được. Syntax: - [keyword to exclude] [keyword to include] Ví dụ: Vẫn là ví dụ kia nhưng lần này bạn không muốn kết quả trả về liên quan đến golang bạn hãy thử: Và cũng hưu ích khi bạn muốn kết quả tìm kiếm không trả về các trang quảng cáo bằng cách dùng - quảng cáo 3. Google Search Within a Website Mô tả: Tìm kiếm một từ trong trang web - sử dụng cú pháp trang web: URL trang web, theo sau là cụm từ tìm kiếm của bạn. sẽ hạn chế kết quả tìm kiếm và chỉ tìm kiếm trong trang web đó trang web đó. Syntax: site:[website URL] [keywords] Ví dụ: Bạn muốn tìm kiếm nội dung chỉ trong trang viblo thì bạn thử 4. Google Search Definitions Mô tả: Dễ dàng tìm thấy định nghĩa của một từ mà không cần phải đi đến một trang web từ điển bằng cách sử dụng cú pháp sau: Syntax: define:[keyword] Ví dụ: Bạn muốn định nghĩa thuật toán nổi bọt là gì hãy thử: 5. Google Search Wildcard (Missing or Unknown Words) Mô tả: Tìm kiếm kiểu này sẽ giúp bạn tự động điền 1 số từ bạn không nhớ dõ. nó sẽ có tắc dụng trong tìm kiếm lời bài hát hoặc là tiêu đề 1 cuốn sách nào đó mà bạn chỉ nhớ mang máng. Syntax: [keywords 1] * [keywords 2] Ví dụ: Bạn bạn vừa đi xem 1 bộ phim rất hay được chuyển thể từ truyện . mà bạn không nhớ dõ nó có tiêu đề là gì mà chỉ nhớ có từ mắt gì đó. không biết là “mắt liếc” hay “mắt lác” thì bạn hãy thử: 6. Google Search File Type Mô tả: Cái này sẽ giúp bạn tìm kiếm theo kiểu file ví dụ như .sql, .docx, .csv … Syntax: [keywords] filetype:[file type extension] Ví dụ: Bạn muốn tìm 1 file mà định dạng là .sql về quận huyện của việt nam chẳng hạn bạn hãy thử: 7. Google Images Search Mô tả: Giúp bạn tìm kiếm nhanh tên hình ảnh, mô tả và type. Syntax: [keyword] image type Ví dụ: Bạn chỉ muốn tìm kiếm anh gif bạn hãy thử : Lời kếtTrên đây là 1 số mẹo nhỏ nó có thể không giúp ích được nhiều với các vấn đề phổ biến nhưng lại rất hữu ích trong các vấn đề ít người gặp phải mà không may bạn lại mắc phải vấn đề đó. vì vậy hãy note lại nhé ! Và nếu có thể thì bạn nên search vấn đề của bạn bằng tiếng anh nhé! Hẹn gặp các bạn trong các bài viết lần sau. thân ái và quyết thắng !!!","categories":[],"tags":[{"name":"trick","slug":"trick","permalink":"https://phamtuananh1996.github.io/tags/trick/"}]},{"title":"Giao tiếp giữa các cửa sổ với Window.postMessage API","slug":"giao-tiep-giua-cac-cua-so-voi-windowpostmessage-api","date":"2020-03-15T13:22:08.000Z","updated":"2020-05-27T05:52:05.613Z","comments":true,"path":"2020/03/15/giao-tiep-giua-cac-cua-so-voi-windowpostmessage-api/","link":"","permalink":"https://phamtuananh1996.github.io/2020/03/15/giao-tiep-giua-cac-cua-so-voi-windowpostmessage-api/","excerpt":"","text":"Mở đầuBạn đã bao giờ có nhu cầu giao tiếp giữa các cửa sổ hoặc cửa sổ hiện tại và iframe bên trong chưa. như truyền data từ cửa sổ này đến cửa sổ kia và ngược lại. Vậy làm cách nào để làm được điều đó? thì window.postMessage api chính là giải pháp của bạn? chúng ta cùng tìm hiểu trong bài viết này nhé!! Cú pháp1targetWindow.postMessage(message, targetOrigin, [transfer]); Với các tham số được mô tả bằng bảng dưới đây: Tên Mô tả targetWindow Reference tới một windows hoặc iframe nào đó mà bạn muốn gửi message, giá trị này được trả về khi gọi hàm window.open hoặc tên, id của frame trong biến window.frames message Dữ liệu cần gửi đến targetOrigin, có thể là string hoặc objec ….. targetOrigin Là trang sẽ nhận được message này. Hoặc có thể là “*” thì message này sẽ được gửi đến mọi window target đến nó (Không khuyến khích dùng) Gửi MessageĐể dõ hơn mình sẽ tạo ra 2 cửa sổ window như này: Window 1 (http://localhost:8002/window-1) Window 2 (http://localhost:8002/window-2) Tiếp theo mình sẽ viết code js cho window 1 để gửi message cho window 2: 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;This is window 1&lt;/h1&gt; &lt;button onClick=\"sendHello()\"&gt;Send hello to window 2&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; function sendHello() &#123; var popup = window.open(\"http://localhost:8002/window-2\", 'window-2'); popup.postMessage(\"Hello, window-2! i am window-1\", \"http://localhost:8002/window-2\"); &#125;&lt;/script&gt; Nhận MessageTiếp theo viết code nhận message từ window-1 cho window-2 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;This is window 2&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; window.addEventListener(\"message\", function (event) &#123; if (event.origin !== \"http://localhost:8001/window-1\") return; alert(event.data) &#125;);&lt;/script&gt; Các thuộc tính nhận được sẽ bao gồm: Tên Mô tả data Đối tượng được truyền đến origin Nguồn gốc của data truyền đến. bạn phải kiểm tra trường này để tranh trường hợp người khác giả mạo sender cũng như xử lý những message không liên quan tới mình source reference đến đối tượng cửa sổ đã gửi tin nhắn; bạn có thể sử dụng điều này để thiết lập giao tiếp hai chiều giữa hai cửa sổ với nguồn gốc khác nhau. Thành quả sẽ như thế này : Vấn đề về bảo mật Nếu trang web của bạn không muốn nhận message từ các trang khác gửi tới thì tuyệt đối không lắng nghe event message dưới đây: 1window.addEventListener(\"message\", receiveMessage, false); Nếu bạn bắt buộc phải nhận message từ những trang khác thì luôn luôn xác minh danh tính của trang gửi đến bằng cách sử dụng origin 12if (event.origin !== \"http://localhost:8001/window-1\") return; Bất kỳ window nào cũng có thể gửi tin nhắn đến các window khác, và bạn không phải biết tin nhắn đó có độc hại hay không vì vậy không chỉ xác minh danh tính của window gửi đến mà bạn còn phải luôn xác minh cú pháp của tin nhắn nhận được Luôn chỉ định chính xác targetOrigin.và không dùng “*” khi bạn sử dụng postMessage để gửi data đến window khác. Tổng kếtHy vọng qua bài này bạn có thể sự dụng window.postMessage để giao tiếp giữa các window 1 cách an toàn và hiệu quả nhất. :100::100::100::100::100::100::astonished:","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://phamtuananh1996.github.io/tags/javascript/"}]},{"title":"Tạo mechanism webhook cho riêng mình với laravel notification.","slug":"tao-mechanism-webhook-cho-rieng-minh-voi-laravel-notification","date":"2019-12-15T08:51:17.000Z","updated":"2020-05-27T05:58:04.225Z","comments":true,"path":"2019/12/15/tao-mechanism-webhook-cho-rieng-minh-voi-laravel-notification/","link":"","permalink":"https://phamtuananh1996.github.io/2019/12/15/tao-mechanism-webhook-cho-rieng-minh-voi-laravel-notification/","excerpt":"","text":"Mở đầuHôm nay mình sẽ hướng dẫn cho các bạn cách tạo một webhook mechanism cho riêng mình. từ lâu chúng ta đã biểt đến và dùng chức năng webhook của github, facebook … .Đại loại là họ sẽ cho mình nhập 1 Payload URL và chọn sự kiện để khi có sự kiện đó thì github cũng send http request đến Payload URL của người dùng. Tương tự vậy, ở demo nay chúng ta sẽ cho phép người dùng nhập webhook url của họ. và khi có 1 sự kiện nào đó trên hệ thống chúng ta thì hệ thống cũng tiến hành send http request đến url của họ (request gồm body và header). Webhook là gì?Cài đặt DependenciesĐầu tiên chúng ta cần cài đặt package để cho việc gửi HTTP request. Ở đây mình dùng thư viện khá phổ biến là Guzzle: 1composer require guzzlehttp&#x2F;guzzle:~6.0 Migrate dữ liệuTiếp theo chúng ta tạo bảng user. ở ví dụ demo này thì mình sẽ lưu name, email, password, api_token và đặc biệt có thêm trường webhook_url đây chính là enpoint của người dùng khi đăng ký Webhook End Point trên hệ thống của chúng ta. 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpuse Illuminate\\Support\\Facades\\Schema;use Illuminate\\Database\\Schema\\Blueprint;use Illuminate\\Database\\Migrations\\Migration;class CreateUsersTable extends Migration&#123; /** * Run the migrations. * * @return void */ public function up() &#123; Schema::create('users', function (Blueprint $table) &#123; $table-&gt;increments('id'); $table-&gt;string('name'); $table-&gt;string('email')-&gt;unique(); $table-&gt;string('password'); $table-&gt;string('api_key'); $table-&gt;string('webhook_url')-&gt;nullable(); $table-&gt;rememberToken(); $table-&gt;timestamps(); &#125;); &#125; /** * Reverse the migrations. * * @return void */ public function down() &#123; Schema::dropIfExists('users'); &#125;&#125; Tạo modelTiếp theo là tạo model User 12345678910111213141516171819202122232425262728293031323334353637383940414243namespace App;use Illuminate\\Notifications\\Notifiable;use Illuminate\\Foundation\\Auth\\User as Authenticatable;class User extends Authenticatable&#123; use Notifiable; /** * The attributes that are mass assignable. * * @var array */ protected $fillable = [ 'name', 'email', 'password', 'api_key', 'webhook_url', ]; /** * The attributes that should be hidden for arrays. * * @var array */ protected $hidden = [ 'password', 'remember_token', 'api_key', ]; /** * @return string */ public function getSigningKey() &#123; return $this-&gt;api_key; &#125; /** * @return string */ public function getWebhookUrl() &#123; return $this-&gt;webhook_url; &#125;&#125; Model này khá dễ hiểu rồi. mình có thêm 2 hàm getSigningKey và getWebhookUrl để lấy api_key và webhook_url Tạo notification channelsTiếp theo chúng ta cần tạo 1 notification channel. Thì laravel có hỗ trợ chúng ta tạo cũng như custom notification channels ở Tại đây. Tiến hành tạo WebhookChannel 123456789101112131415161718192021222324252627282930&lt;?phpnamespace App\\Channels;use GuzzleHttp\\Client;use Illuminate\\Log\\Logger;use Illuminate\\Notifications\\Notifiable;use Illuminate\\Notifications\\Notification;class WebhookChannel&#123; /** * @var Client */ private $client; /** * @var Logger */ private $logger; public function __construct(Client $client, Logger $logger) &#123; $this-&gt;client = $client; $this-&gt;logger = $logger; &#125; /** * @param Notifiable $notifiable * @param Notification $notification * @throws WebHookFailedException */ public function send($notifiable, Notification $notification) &#123; &#125;&#125; Function send là nơi chúng ta viết code để thực hiện việc send http request đến endpoint (webhook_url) của người dùng. Tiếp theo mình tiến hành viết hàm send Đầu tiên , 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * @param Notifiable $notifiable * @param Notification $notification * @throws WebHookFailedException */ public function send($notifiable, Notification $notification) &#123; if (method_exists($notification, 'toWebhook')) &#123; $body = (array) $notification-&gt;toWebhook($notifiable); &#125; else &#123; $body = $notification-&gt;toArray($notifiable); &#125; $timestamp = now()-&gt;timestamp; $token = str_random(16); // Tạo header cho request webhook . cái này để người dùng có thể xác minh request gửi lên là từ hệ thống của chúng ta mà không phải từ hệ thông khác $headers = [ 'timestamp' =&gt; $timestamp, 'token' =&gt; $token, 'signature' =&gt; hash_hmac( 'sha256', $token . $timestamp, $notifiable-&gt;getSigningKey() ), ]; // Tiếp theo chúng ta tạo 1 request sử dụng GuzzleHttp để gửi request $request = new Request('POST', $notifiable-&gt;getWebhookUrl(), $headers, json_encode($body)); try &#123; $response = $this-&gt;client-&gt;send($request); // kiểm tra nếu không nhận được status code = 200 thì sẽ báo lỗi if ($response-&gt;getStatusCode() !== 200) &#123; throw new WebHookFailedException('Webhook received a non 200 response'); &#125; // Lưu lại log $this-&gt;logger-&gt;debug('Webhook successfully posted to '. $notifiable-&gt;getWebhookUrl()); return; &#125; catch (ClientException $exception) &#123; if ($exception-&gt;getResponse()-&gt;getStatusCode() !== 410) &#123; throw new WebHookFailedException($exception-&gt;getMessage(), $exception-&gt;getCode(), $exception); &#125; &#125; catch (GuzzleException $exception) &#123; throw new WebHookFailedException($exception-&gt;getMessage(), $exception-&gt;getCode(), $exception); &#125; $this-&gt;logger-&gt;error('Webhook failed in posting to '. $notifiable-&gt;getWebhookUrl()); &#125; Vậy là xong 1 notification channels. Tiếp theo mình chỉ việc gọi Webhook notification và dùng thôi. Thực hiện notification webhookTiếp theo chúng ta tạo notification bằng lệnh 1php artisan make:notification SomethingHappenedNotification Tiến hành viết code. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?phpnamespace App\\Notifications;use App\\Channels\\WebhookChannel;use Illuminate\\Bus\\Queueable;use Illuminate\\Notifications\\Notification;use Illuminate\\Contracts\\Queue\\ShouldQueue;class SomethingHappenedNotification extends Notification implements ShouldQueue&#123; use Queueable; /** * @var string */ private $message; /** * Create a new notification instance. * * @param string $message */ public function __construct($message) &#123; // $this-&gt;message = $message; &#125; /** * Get the notification's delivery channels. * * @param mixed $notifiable * @return array */ public function via($notifiable) &#123; return [WebhookChannel::class]; &#125; public function toWebhook($notifiable) &#123; return [ 'message' =&gt; $this-&gt;message, ]; &#125; /** * Get the array representation of the notification. * * @param mixed $notifiable * @return array */ public function toArray($notifiable) &#123; return []; &#125;&#125; ok. vậy là đã xong . giờ chúng ta có thể tạo các sự kiện và send notification đến endpoint mà người dùng đã đăng ký. 123use App\\Notifications\\SomethingHappenedNotification;$user-&gt;notify(new SomethingHappenedNotification($massage)); Kết luậnCảm ơn các bạn đã đọc đến đây. Tham khảo : https://laravel.com/docs/5.6/notifications#custom-channels, Source code: https://github.com/phamtuananh1996/laravel-webhook-demo","categories":[],"tags":[{"name":"laravel","slug":"laravel","permalink":"https://phamtuananh1996.github.io/tags/laravel/"}]},{"title":"Chống sao chép hình ảnh bất hợp pháp với watermark image","slug":"chong-sao-chep-hinh-anh-bat-hop-phap-voi-watermark-image","date":"2019-11-11T07:31:21.000Z","updated":"2020-05-27T05:56:06.424Z","comments":true,"path":"2019/11/11/chong-sao-chep-hinh-anh-bat-hop-phap-voi-watermark-image/","link":"","permalink":"https://phamtuananh1996.github.io/2019/11/11/chong-sao-chep-hinh-anh-bat-hop-phap-voi-watermark-image/","excerpt":"","text":"watermark image là gì?Gần đây mình thấy trên viblo có mội số bài viết khá hay và chất lượng. Nhưng điều đáng buồn là các trang web về công nghệ khác đã copy các bài viết này mà không xin phép tác giả hay có thì cũng chỉ là ghi link tới bài viết rất nhỏ ở cuối bài.Cũng chính vì lý do đó mà các tác giả của viblo gần đây đã gắn thêm watermark vào hình ảnh của mình. Như chính bài này sau 1 thời gian thì cũng đã bị copy https://topdev.vn/blog/chong-sao-chep-hinh-anh-bat-hop-phap-voi-watermark-image/ tại trang này. :joy::joy::joy::joy::joy: dưới đây là 1 ví dụ về watermark: bạn có thể thấy ở góc bottom-right có ảnh cái mẹt của mình. và như để khẳng định nguồn hình ảnh bài viết này là của mình. :rofl::rofl::rofl::rofl::rofl::rofl::rofl::rofl::rofl::rofl::rofl: vậy watermark là gì ? Khái niệm Watermark là gì? Watermark được hiểu là một dấu hiệu nhận biết như text, Image, logo hay slogan của riêng bạn hoặc công ty bạn được in hoặc làm chìm, làm mờ phía đăng sau bức ảnh. Mục đích của việc làm này chính là đánh dấu hoặc đặt ra dấu hiệu nhận biết đó là sản phẩm của bạn làm ra. Khi người khác lấy ảnh hoặc tài liệu của bạn để sử dụng cho website của họ. Mặc định người ta biết rằng đó là ảnh của bạn làm ra. Ý nghĩa của việc sử dụng Watermark là gì? Chống sao chép bất hợp pháp hoặc chưa có sự đồng ý của chủ nhân tác phẩm. Đặc biệt trong bán hàng online trên mạng, hay thậm chí việc sử dụng lại hình ảnh của nhau là điều thường xảy ra. Khi đối thủ cạnh tranh của bạn sử dụng lại hình ảnh của bạn một cách trái phép để làm công cụ riêng của họ thì việc gắn Watermark cho tác phẩm của mình là điều cần thiết. Bạn có thể sử dụng logo chìm, hotline hoặc tên của bạn làm mờ phía sau ảnh. Điều này đảm bảo cho bạn dễ dàng bảo vệ được tác phẩm của mình. Hỗ trợ quảng bá và tăng độ phủ của thương hiệu Việc sử dụng Watermark là một trong nhiều yếu tố được các thương hiệu nổi tiếng sử dụng để quảng bá thương hiệu của bạn dễ dàng. Ngoài việc bảo vệ bản quyền tác phẩm, bạn còn có thể sử dụng Watermark làm một trong các công cụ để giới thiệu công ty. Nếu ảnh của bạn chất lượng, sẽ có rất nhiều người lấy ảnh của bạn để chia sẻ và đăng tải. Điều này không hề có hại mà ngược lại sẽ giúp doanh nghiệp của bạn được quảng bá dễ dàng hơn rất nhiều. Đây chính là điểm mạnh của Watermark giúp bạn phát triển được tiềm năng thương hiệu. Tạo ra điểm nhấn của tác phẩm Sự chăm chút trong tác phẩm của bạn từ chi tiết tới Watermark cũng có thể giúp bạn gây ấn tượng với người xem. Ngoài việc đóng dấu bản quyền, chúng còn đem lại một điểm nhấn sáng tạo cho bức hình của chính bạn hoặc của công ty. Demo watermark image với intervention Lý thuyết vậy đủ rồi giờ thực hành thôi Cài đặt thư viện Yêu cầu môi trường: PHP &gt;= 5.4 Fileinfo Extension GD Library (&gt;=2.0) Imagick PHP extension (&gt;=6.5.7) Đầu tiên chạy lệnh này để tiến hành clone thư viện về project: 1composer require intervention&#x2F;image Trong file config/app.php thêm providers 1Intervention\\Image\\ImageServiceProvider::class và thêm aliases 1&#39;Image&#39; &#x3D;&gt; Intervention\\Image\\Facades\\Image::class Vậy là xong phần cài đặt tiếp theo bắt tay vào code chức năng watermark image. DemoNếu bạn truy cập vào document của thư viện tại đây thì đã có hẳn một ví dụ về việc watermark này: 1234567891011// open an image file$img = Image::make('public/foo.jpg');// now you are able to resize the instance$img-&gt;resize(320, 240);// and insert a watermark for example$img-&gt;insert('public/watermark.png');// finally we save the image as a new file$img-&gt;save('public/bar.jpg'); Dựa vào ví dụ của doc thì mình cần 2 ảnh 1 là ảnh cần watermark và 1 ảnh watermark. Mình sẽ dùng 2 ảnh này cho nó cute! Ảnh gốc (ảnh mình muốn gắn watermark) có tên foo.jpg Ảnh watermark ( dùng luôn cái mặt mình ) có tên watermark.png 2 ảnh này mình để trong fodel public của project Tiến hành code thôi. mình sửa lại đoạn code ví dụ của doc 1 chút : 123456789101112131415161718192021222324252627282930313233// Mở ảnh gốc$img = Image::make('public/foo.jpg');// Mở ảnh watermark$watermark = Image::make('public/watermark.jpg');//làm mờ ảnh watermark$watermark = $watermark-&gt;opacity(50);// resize ảnh watermark (= 1/10 ảnh gốc)$resizePercentage = 10/100;$watermarkSize = round($image-&gt;width() * $resizePercentage, 2);$watermark-&gt;resize($watermarkSize, null, function ($constraint) &#123; $constraint-&gt;aspectRatio();&#125;)//set position : vị trí của ảnh watermark ở đây mình để góc dười bên phải$position = 'bottom-right'; // có thể chọn các vị trí:// top-left (default)// top// top-right// left// center// right// bottom-left// bottom// bottom-right// Tiến hành watermark $img-&gt;insert($watermark, $position);// finally we save the image as a new file$img-&gt;save('public/bar.jpg'); vậy là done! Kết luậnQua bài viết này mình mong các bạn có thêm 1 sự lựa chọn cho website của mình về việc bản quyền. Chúc các bạn thành công :heart_eyes::heart_eyes::heart_eyes::heart_eyes::heart_eyes: Tài liệu tham khảo: https://haviweb.com.vn/watermark-la-gi/ http://image.intervention.io","categories":[],"tags":[{"name":"laravel","slug":"laravel","permalink":"https://phamtuananh1996.github.io/tags/laravel/"}]},{"title":"Biến ảnh sprites thành ảnh động với vuejs","slug":"bien-anh-sprites-thanh-anh-dong-voi-vuejs","date":"2019-09-15T04:28:12.000Z","updated":"2020-05-27T06:04:54.600Z","comments":true,"path":"2019/09/15/bien-anh-sprites-thanh-anh-dong-voi-vuejs/","link":"","permalink":"https://phamtuananh1996.github.io/2019/09/15/bien-anh-sprites-thanh-anh-dong-voi-vuejs/","excerpt":"","text":"Ảnh sprites là gì?Sprites là một hình ảnh lớn được tạo ra bằng cách gộp nhiều ảnh nhỏ lại với nhau theo một cách được định trước sao cho có thể tái sử dụng lại từng ảnh nhỏ mà không bị ảnh hưởng bởi các ảnh khác. Kiểu như thế này : Hoặc các sticker của fb: Mục tiêu của bài viết Qua bài viết này mình muốn chuyển các ảnh sprites đứng yên kia thành anh động bằng cách viết 1 component vuejs. Các bạn cũng có thể tham khảo cách khác bằng canvas của HTML5 qua bài viết này : https://viblo.asia/p/cach-tao-anh-giong-gif-bang-javascript-khong-phai-ai-cung-biet-YWOZr6xrZQ0 Ưu điểm so với việc dùng ảnh gif Tôi ưu hơn performance web vì thay vì load ảnh gif thì thay vào đó là anh png. Có thể tương tác với ảnh (vd: có thể cho ảnh dừng lại hoặc tiếp tục chuyển động, hoặc chuyển động vs số lần nhất định rồi ngừng). Tùy chỉnh chuyển động nhanh chậm của ảnh.Xây dựng component vuejsHướng giải quyếtĐơn giản chỉ là dùng js để thay đổi background-position qua từng phần của bước ảnh và lặp lại khi đến ảnh cuối vậy là mình đã có 1 ảnh tương tự gif. Viết componentKhởi tạo các props và style cho component: 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div :style=\"style\"&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; clearInterval &#125; from 'timers';export default &#123; props: &#123; image: String, // Url image height: Number, // chiều cao của component width: Number, // chiều rộng của component loop: Number, // số lần lặp của ảnh frame: Number, // số hình chạy qua trên 1 giây max: Number, // số hình của ảnh column: Number, // số cột row: Number, // số dòng &#125;, data()&#123; // khởi tạo style ban đầu return &#123; style: &#123; width: this.width + 'px', height: this.height + 'px', background: `url($&#123;this.image&#125;)`, backgroundSize: `$&#123;this.width * this.column&#125;px $&#123;this.height * this.row&#125;px`, backgroundPosition: '0px 0px' &#125; &#125; &#125;, Tiếp theo chúng ta viết function để ảnh có thể chuyển động. 12345678910111213141516171819202122232425262728293031methods: &#123; play() &#123; let i = 0 let position = &#123; x: 0, y: 0, loop: 0, &#125; // khởi tạo vị trí ban đầu const playTimer = setInterval(() =&gt; &#123; i++; if(i % this.column) &#123; position.x -= this.width; &#125; else &#123; position.y -= this.height; position.x = 0; &#125; if (i == this.max) &#123; i = 0 position.y = 0; position.x = 0; position.loop++; if(position.loop &gt;= this.loop) &#123; clearInterval(playTimer) &#125; &#125; this.$set(this.style, 'backgroundPosition', `$&#123;position.x&#125;px $&#123;position.y&#125;px`) // set lại style &#125;, 1000/this.frame); &#125; &#125; Gọi hàm play() 123mounted() &#123; this.play() &#125;, Vậy là chúng ta đã viết xong component để ảnh chuyện động. full code : 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;template&gt; &lt;div :style=\"style\"&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'HelloWorld', props: &#123; image: String, height: Number, width: Number, loop: Number, frame: Number, max: Number, column: Number, row: Number, &#125;, mounted() &#123; this.play() &#125;, data()&#123; return &#123; style: &#123; width: this.width + 'px', height: this.height + 'px', background: `url($&#123;this.image&#125;)`, backgroundSize: `$&#123;this.width * this.column&#125;px $&#123;this.height * this.row&#125;px`, backgroundPosition: '0px 0px' &#125; &#125; &#125;, methods: &#123; play() &#123; let i = 0 let position = &#123; x: 0, y: 0, loop: 0, &#125; const playTimer = setInterval(() =&gt; &#123; i++; if(i % this.column) &#123; position.x -= this.width; &#125; else &#123; position.y -= this.height; position.x = 0; &#125; if (i == this.max) &#123; i = 0 position.y = 0; position.x = 0; position.loop++; if(position.loop &gt;= this.loop) &#123; clearInterval(playTimer) &#125; &#125; this.$set(this.style, 'backgroundPosition', `$&#123;position.x&#125;px $&#123;position.y&#125;px`) &#125;, 1000/this.frame); &#125; &#125;&#125;&lt;/script&gt; Việc tiếp theo là chúng ta gọi component này ra và sử dụng thôi. Mình test thử với ảnh này nhé: 12345678910111213141516171819202122232425&lt;template&gt; &lt;div id=\"app\"&gt; &lt;ImageGif image = \"https://images.viblo.asia/a28b8126-1298-4ca7-a507-53865b32238d.png\" :width=\"100\" :height=\"100\" :column=\"7\" :row=\"4\" :max=\"27\" :frame=\"20\" :loop=\"10\" /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ImageGif from './components/image-gif.vue'export default &#123; name: 'app', components: &#123; ImageGif &#125;&#125;&lt;/script&gt; Thành quả : https://codesandbox.io/s/vue-template-znn3p Kết luậnCác bạn cũng có thể tham khảo thêm github:https://github.com/tuananhp-1844/image-gif","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://phamtuananh1996.github.io/tags/javascript/"},{"name":"vuejs","slug":"vuejs","permalink":"https://phamtuananh1996.github.io/tags/vuejs/"}]},{"title":"\"Đóng trình duyệt, session mất\" hiểu thế nào cho đúng?","slug":"dong-trinh-duyet-session-mat-hieu-the-nao-cho-dung","date":"2019-08-07T08:34:39.000Z","updated":"2020-05-27T06:08:38.110Z","comments":true,"path":"2019/08/07/dong-trinh-duyet-session-mat-hieu-the-nao-cho-dung/","link":"","permalink":"https://phamtuananh1996.github.io/2019/08/07/dong-trinh-duyet-session-mat-hieu-the-nao-cho-dung/","excerpt":"","text":"Đặt vấn đềMình đã nghe rất nhiều người nói “session sẽ mất khi đóng trình duyệt”. Đặc biết là khi còn là sinh viên thì câu này là câu “thần chú” khi đi phỏng vấn. Vậy có phải khi đóng trình duyệt thật sự session sẽ mất không ? Và session còn mất trong các trường hợp nào nữa? Note: Bài này mình dùng ngôn ngữ php và nginx nhé Session là gì?Một session hay còn gọi là một phiên làm việc. Trong khoa học máy tính, Nó đơn giản là cách giao tiếp giữa client với server. Một session bắt đầu khi client gửi request đến sever, nó tồn tại xuyên suốt từ trang này đến trang khác trong ứng dụng và chỉ kết thúc khi hết thời gian timeout . Giá trị của session sẽ được lưu trong một tệp tin trên máy chủ. Khái niệm session chắc không quá xa lạ nữa. Mình muốn làm dõ hơn nữa khái niệm này: *”Giá trị của session sẽ được lưu trong một tệp tin trên máy chủ”* Mình muốn biết tập tin đó lưu trữ nhưng gì và ở đâu ? Mình sẽ tạo ra 1 session và lưu 1 số giá trị vào: 1234567&lt;?phpsession_start();$_SESSION[\"color\"] = \"red\";$_SESSION[\"color1\"] = \"yellow\";echo \"Session is created\"; Sau đó mở trình duyệt chrome để chạy.Vậy là mình đã tạo session thành công. Thì mặc định session sẽ được lưu /var/lib/php/session nhé và chúng ta có thể thay đổi nơi lưu trữ session trong file php.ini Mình thấy có file sess_qg2vvqet5ft791f4hgc49hcqr8 được tạo ra. thử mở ra xem có gì bên trong nào Vậy là trong file lưu tên và giá trị mà chúng ta vừa set vào còn s:3 và s:6 là kiểu dữ liệu và độ dài (String độ dài 3 và String độ dài 6) Cách phân biệt session của các trình duyệt khác nhau Session khi sinh ra được lưu trên 1 file có tên dài dòng, khó đoán và được tạo ngẫu nhiên là session id trên máy chủ, và đồng thời gửi lại cho client 1 Session cookie (không phải session) có nội dung (hay giá trị) đúng như session id (để có thể so khớp session nào là của client nào). Session cookie (không phải session) khác với cookie thông thường đó là khi đóng trình duyệt thì loại cookie này sẽ mất. Vậy chúng ta tìm trên trình duyệt chrome xem cookie này như thế nào: Đối với mỗi ngôn ngữ lập trình web sẽ có tên Session cookie quy định như php là PHPSESSID, jsp là JSESSIONID, … Vậy PHPSESSID của trình duyệt này là qg2vvqet5ft791f4hgc49hcqr8 và nó match đúng với file vừa được tạo ra trên server. Để làm dõ hơn thì mình mở bằng trình duyệt firefox Sau khi chạy thì mình thấy trên server có tạo thêm 1 file sess_su7q6pskehc3nfqiu479p4oqvn Và session cookie của trình duyệt firefox cũng match đúng với file đó. Vậy dựa vào PHPSESSID đó mà server có thể phân biệt được session nào là của trình duyệt nào. Timeout của sessionLà khoảng thời gian mà session tồn tại nếu không có request từ client đến server . mặc định là 24 phút .bạn cũng có thể thay đổi khoảng thời gian này phong file php.ini Quay lại vấn đềDựa vào những thứ tìm được từ bên trên mình sẽ đặt giả thiết thế này cho hình dung: Tủ (session) :file_cabinet: Chìa khóa (Session cookie) :old_key: Bạn (client) :speak_no_evil: người cho thuê tủ (server) :pig: Đồ dùng trong tủ (nội dung của session) :cookie: Qui định : Mỗi chìa khóa chỉ mở được 1 tủ, mỗi tủ có đồ dùng bên trong. Nếu bạn không quay lại sử dụng tủ thì tủ sẽ bị thi hồi sau 1 khoảng thời gian (do người cho thuê quyết định) kể cả bạn có chìa khóa. :joy::joy: Nếu làm mất chìa khóa thì bạn sẽ không sử dụng được tủ. Như đã biết thì đóng trình duyệt thì Session cookie sẽ mất. Trường hợp này được tưởng tượng như sau: Người cho thuê tủ cho bạn thuê tủ và đưa cho bạn chìa khóa để sử dụng cái tủ đấy. nhưng vô tình bạn làm mất chìa khóa. Mặc dù vẫn có tủ ở đấy. Và theo quy định bạn không sử dụng tủ trong 1 khoảng thời gian thì tủ sẽ bị thu hồi. Vậy câu “session sẽ mất khi đóng trình duyệt” Trường hợp này sẽ là:Tủ sẽ bị thu hồi khi bạn mất chìa khóa. nhưng thật ra bạn mất chìa khóa thì tủ vẫn còn đó. chỉ là do không có chìa khóa bạn không thể sử dụng được tủ và do không sử dụng lên sau 1 khoảng thời gian tủ sẽ bị thu hồi. Kết luậnVậy đóng trình duyệt thì session bị mất . Lý do là khi đóng trình duyện thì Session cookie của bạn bị xóa. và vì không có cái Session cookie nữa .lên server không biết bạn là ai còn cái session cũ của bạn thì vẫn còn ở đó. và do sau 1 khoảng thời gian được qui định session ấy không được sử dụng đến vì vậy nó đã bị kill Qua bài viết này mình muốn làm dõ hơn vì sao đóng trình duyệt thì session bị mất. qua đó cũng hiểu dõ hơn về cớ chế hoạt động của session. Cảm ơn các bạn đã đọc đến đây ạ :heart_eyes::heart_eyes::heart_eyes::heart_eyes::heart_eyes::heart_eyes:","categories":[],"tags":[{"name":"cookie","slug":"cookie","permalink":"https://phamtuananh1996.github.io/tags/cookie/"},{"name":"session","slug":"session","permalink":"https://phamtuananh1996.github.io/tags/session/"}]},{"title":"CRUD Unit Testing trong Laravel","slug":"crud-unit-testing-trong-laravel","date":"2019-07-01T10:08:37.000Z","updated":"2020-05-27T06:12:45.247Z","comments":true,"path":"2019/07/01/crud-unit-testing-trong-laravel/","link":"","permalink":"https://phamtuananh1996.github.io/2019/07/01/crud-unit-testing-trong-laravel/","excerpt":"","text":"Giới thiệu1. UnitTest là gì? UnitTest: Kiểm thử ở mức đơn vị mã nguồn. Một đơn vị mã nguồn là thành phần nhỏ nhất trong mã nguồn mà chúng ta có thể kiểm tra như. Trong Unit Test ta sẽ kiểm thử các class, method,…Mục tiêu của unit testing là kiểm tra tính đúng đắn trong các xử lý của từng đơn vị mã nguồn. Hiểu đơn giản đây là công việc viết code để test code chúng ta viết ra. Để thực hiện công việc này chúng ta cần PHPUnit và trong Laravel tích hợp sẵn PHPUnit. Trong bài viết này mình sẽ demo 1 ví dụ về unit test Tạo model và migrationCác bạn chạy lệnh để tạo ra model và migration Category 1php artisan make:model Category -m Ở file Model App\\Category.php : 12345678910111213&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Category extends Model&#123; protected $fillable = [ 'name', 'description', ];&#125; Viết migrate tạo table categories: 123456789101112131415161718192021222324252627282930313233&lt;?phpuse Illuminate\\Support\\Facades\\Schema;use Illuminate\\Database\\Schema\\Blueprint;use Illuminate\\Database\\Migrations\\Migration;class CreateCategoriesTable extends Migration&#123; /** * Run the migrations. * * @return void */ public function up() &#123; Schema::create('categories', function (Blueprint $table) &#123; $table-&gt;bigIncrements('id'); $table-&gt;string('name'); $table-&gt;string('description')-&gt;nullable(); $table-&gt;timestamps(); &#125;); &#125; /** * Reverse the migrations. * * @return void */ public function down() &#123; Schema::dropIfExists('categories'); &#125;&#125; Vậy là tạo xong model và migration chạy lệnh 1php artisan migrate để thực thi file migration vừa tạo. Tiếp theo , tạo các chức năng CRUD cho Category , ở đây mình dùng repository nhé! Tạo các crud function trong repositoryỞ đây mình tập trung nhiều vào phần test lên mình tạo file repository đơn giản. Các bạn tạo file App\\Repositories\\CategoryRepository.php và tạo các function CRUD như sau: 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpnamespace App\\Repositories;use App\\Category;class CategoryRepository&#123; protected $model; public function __construct() &#123; $this-&gt;model = $this-&gt;model = app()-&gt;make(Category::class); &#125; // Tạo category public function storeCategory($data) : Category &#123; $category = $this-&gt;model-&gt;create($data); return $category; &#125; // Update category public function updateCategory($data, $category) : bool &#123; return $category-&gt;update($data); &#125; // Show category public function showCategory($category_id) : Category &#123; return $this-&gt;model-&gt;findOrFail($category_id); &#125; // Destroy category public function destroyCategory($category) : bool &#123; return $this-&gt;model-&gt;delete(); &#125;&#125; Vậy là đã xong các chức năng thêm sửa xóa rồi. bắt đầu viết test thôi !!! :100::100: Tiến hành tạo CRUD Unit TestingĐể tạo 1 test, ta sử dụng câu lệnh: 1234&#x2F;&#x2F; Tạo 1 test trong thư mục Feature php artisan make:test CategoryTest&#x2F;&#x2F; Tạo 1 test trong thư mục Unit php artisan make:test CategoryTest --unit Lưu ý: Nội dung bên trong thư mục Feature hay Unit có cấu trúc giống thư mục app/ ví dụ app/Repositories/CategoryRepository.php thì trong thư mục Unit là test/Unit/Repositories/CategoryRepository.php cho dễ quản lý nhé Ở đây mình tạo unit test lên chạy lệnh: 1php artisan make:test Repositories&#x2F;CategoryTest --unit Trước khi viết test mình lưu ý 2 function sau: setUp() : Chạy trước mỗi method test. Sử dụng khi muốn khởi tạo biến, mở kết nối file,… chuẩn bị môi trường để test tearDown(): Chạy sau mỗi method test. Sử dụng để hủy các biến, kết nối,… Ví dụ : 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpnamespace Tests\\Unit\\Repositories;use Tests\\TestCase;use Illuminate\\Foundation\\Testing\\WithFaker;use Illuminate\\Foundation\\Testing\\RefreshDatabase;class CategoryTest extends TestCase&#123; public function setUp() : void &#123; parent::setUp(); &#125; public function tearDown() : void &#123; parent::tearDown(); &#125; /** * A basic unit test example 1. * * @return void */ public function testExample1() &#123; $this-&gt;assertTrue(true); &#125; /** * A basic unit test example 2. * * @return void */ public function testExample2() &#123; $this-&gt;assertTrue(true); &#125;&#125; Việc test sẽ lần lượt chạy như sau: Method: setUp() Method: testExample1() Method: tearDown() Method: setUp() Method: testExample2() Method: tearDown() Test chức năng tạo (store)Trong file CategoryTest.php 123456789101112131415161718192021222324252627282930313233343536373839404142use Tests\\TestCase;use Illuminate\\Foundation\\Testing\\WithFaker;use Illuminate\\Foundation\\Testing\\RefreshDatabase;use App\\Repositories\\CategoryRepository;use App\\Category;use Faker\\Factory as Faker;class CategoryTest extends TestCase&#123; protected $category; public function setUp() : void &#123; parent::setUp(); $this-&gt;faker = Faker::create(); // chuẩn bị dữ liệu test $this-&gt;category = [ 'name' =&gt; $this-&gt;faker-&gt;name, 'description' =&gt; $this-&gt;faker-&gt;name, ]; // khởi tạo lớp CategoryRepository $this-&gt;categoryRepository = new CategoryRepository(); &#125; /** * A basic unit test store * * @return void */ public function testStore() &#123; // Gọi hàm tạo $category = $this-&gt;categoryRepository-&gt;storeCategory($this-&gt;category); // Kiểm tra xem kết quả trả về có là thể hiện của lớp Category hay không $this-&gt;assertInstanceOf(Category::class, $category); // Kiểm tra data trả về $this-&gt;assertEquals($this-&gt;category['name'], $category-&gt;name); $this-&gt;assertEquals($this-&gt;category['description'], $category-&gt;description); // Kiểm tra dữ liệu có tồn tại trong cơ sở dữ liệu hay không $this-&gt;assertDatabaseHas('categories', $this-&gt;category); &#125;&#125; vậy là xong . sau đó chúng ta chạy lệnh để test: 1vendor&#x2F;bin&#x2F;phpunit Nếu trả về như này là đã pass hết trường hợp: 1234567PHPUnit 7.5.13 by Sebastian Bergmann and contributors.... 3 &#x2F; 3 (100%)Time: 373 ms, Memory: 18.00 MBOK (3 tests, 6 assertions) Tương tự với các chức năng show, update, destroy 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?phpnamespace Tests\\Unit\\Repositories;use Tests\\TestCase;use Illuminate\\Foundation\\Testing\\WithFaker;use Illuminate\\Foundation\\Testing\\RefreshDatabase;use App\\Repositories\\CategoryRepository;use App\\Category;use Faker\\Factory as Faker;class CategoryTest extends TestCase&#123; protected $category; public function setUp() : void &#123; parent::setUp(); $this-&gt;faker = Faker::create(); $this-&gt;category = [ 'name' =&gt; $this-&gt;faker-&gt;name, 'description' =&gt; $this-&gt;faker-&gt;name, ]; $this-&gt;categoryRepository = new CategoryRepository(); &#125; /** * A basic unit test store * * @return void */ public function testStore() &#123; $category = $this-&gt;categoryRepository-&gt;storeCategory($this-&gt;category); $this-&gt;assertInstanceOf(Category::class, $category); $this-&gt;assertEquals($this-&gt;category['name'], $category-&gt;name); $this-&gt;assertEquals($this-&gt;category['description'], $category-&gt;description); $this-&gt;assertDatabaseHas('categories', $this-&gt;category); &#125; public function testShow() &#123; $category = factory(Category::class)-&gt;create(); $found = $this-&gt;categoryRepository-&gt;showCategory($category-&gt;id); $this-&gt;assertInstanceOf(Category::class, $found); $this-&gt;assertEquals($found-&gt;name, $category-&gt;name); $this-&gt;assertEquals($found-&gt;description, $category-&gt;description); &#125; public function testUpdate() &#123; // Tạo dữ liệu mẫu $category = factory(Category::class)-&gt;create(); $newCategory = $this-&gt;categoryRepository-&gt;updateCategory($this-&gt;category, $category); // Kiểm tra dữ liệu trả về $this-&gt;assertInstanceOf(Category::class, $newCategory); $this-&gt;assertEquals($newCategory-&gt;name, $this-&gt;category['name']); $this-&gt;assertEquals($newCategory-&gt;description, $this-&gt;category['description']); // Kiểm tra xem cơ sở dữ liệu đã được cập nhập hay chưa $this-&gt;assertDatabaseHas('categories', $this-&gt;category); &#125; public function testDestroy() &#123; $category = factory(Category::class)-&gt;create(); $deleteCategory = $this-&gt;categoryRepository-&gt;destroyCategory($category); // Kiểm tra dữ liệu có trả về true hay không $this-&gt;assertTrue($deleteCategory); // kiểm tra xem dữ liệu đã được xóa trong cơ sở dữ liệu hay chưa $this-&gt;assertDatabaseMissing('categories', $category-&gt;toArray()); &#125;&#125; Tổng kếtHy vọng qua bài viết này các bạn có thể hiểu hơn về unit test Tham khảo: https://medium.com/@jsdecena/crud-unit-testing-in-laravel-5-ac286f592cfdhttps://laravel.com/docs/5.8/testing","categories":[],"tags":[{"name":"laravel","slug":"laravel","permalink":"https://phamtuananh1996.github.io/tags/laravel/"},{"name":"unit test","slug":"unit-test","permalink":"https://phamtuananh1996.github.io/tags/unit-test/"},{"name":"crud","slug":"crud","permalink":"https://phamtuananh1996.github.io/tags/crud/"}]},{"title":"Tìm hiểu về routing trong nuxtjs","slug":"tim-hieu-ve-routing-trong-nuxtjs","date":"2019-06-27T08:49:21.000Z","updated":"2020-05-27T06:15:36.805Z","comments":true,"path":"2019/06/27/tim-hieu-ve-routing-trong-nuxtjs/","link":"","permalink":"https://phamtuananh1996.github.io/2019/06/27/tim-hieu-ve-routing-trong-nuxtjs/","excerpt":"","text":"Giới thiệuNhắc đến ứng dụng web thì routing là 1 thành phần không thể thiếu, Và framework nuxtjs cũng hỗ trợ rất tốt việc này.cùng tìm hiểu nhé ! Nuxt.js tự động tạo ra cấu hình vue-router dựa theo cây thư mục của bạn trong thư mục Pages. Để chuyển hương giữa các trang thay vì dùng thẻ a thì chúng ta dùng &lt; nuxt-link &gt; component Ví dụ: 123&lt;template&gt; &lt;nuxt-link to=\"/\"&gt;Home page&lt;/nuxt-link&gt;&lt;/template&gt; Basic RoutesVí dụ, nếu cấu trúc thư mục của bạn trong pages như này: 12345pages&#x2F;--| user&#x2F;-----| index.vue-----| one.vue--| index.vue Thì nuxt sẽ tự động tạo ra file config route như thế này: 12345678910111213141516171819router: &#123; routes: [ &#123; name: 'index', path: '/', component: 'pages/index.vue' &#125;, &#123; name: 'user', path: '/user', component: 'pages/user/index.vue' &#125;, &#123; name: 'user-one', path: '/user/one', component: 'pages/user/one.vue' &#125; ]&#125; Nhìn khá dễ hiểu phải không. Thay vì mình phải tạo ra file config cho route thì ở nuxt chúng ta chỉ cần tạo cây thư mục trong thư mục pages Dynamic RoutesĐể định nghĩa 1 router với tham số. Thì bạn cần đặt tên thư mục hoặc tên file .vue với tiền tố gạch dưới “_”. Ví dụ, cấu trúc cây thư mục trong Pages của bạn như sau: 1234567pages&#x2F;--| _slug&#x2F;-----| comments.vue-----| index.vue--| users&#x2F;-----| _id.vue--| index.vue Thì nó sẽ tự động generate như sau: 123456789101112131415161718192021222324router: &#123; routes: [ &#123; name: 'index', path: '/', component: 'pages/index.vue' &#125;, &#123; name: 'users-id', path: '/users/:id?', component: 'pages/users/_id.vue' &#125;, &#123; name: 'slug', path: '/:slug', component: 'pages/_slug/index.vue' &#125;, &#123; name: 'slug-comments', path: '/:slug/comments', component: 'pages/_slug/comments.vue' &#125; ]&#125; Validate tham số trên router: Nuxt.js cho phép bạn validate tham số trong phương thức validate() trong component. Ví dụ ở file: pages/users/_id.vue : Chúng ta muốn tham số :id phải là số 123456export default &#123; validate (&#123; params &#125;) &#123; // Must be a number return /^\\d+$/.test(params.id) &#125;&#125; Chú ý : nếu phương thứ validate() trả về false hoặc bị lỗi . Nuxtjs sẽ tự động load ra trang lỗi 404 với trường hợp trả về bằng false và trả về trang lỗi 500 nếu phương thức bị lỗi. Nested RoutesNuxt.js cho phép chúng ta tạo các router lồng nhau. Nếu bạn muốn định nghĩa component cha. bạn cần tạo 1 file .vue giống với tên thư mục mà chứa các view con. Nghe có vẻ lằng nhằng mình vào luôn ví dụ nhé. Ví dụ cấu trúc cây thư mục của mình như sau: 12345pages&#x2F;--| users&#x2F;-----| _id.vue-----| index.vue--| users.vue Nó sẽ tự động generate như này: 1234567891011121314151617181920router: &#123; routes: [ &#123; path: '/users', component: 'pages/users.vue', children: [ &#123; path: '', component: 'pages/users/index.vue', name: 'users' &#125;, &#123; path: ':id', component: 'pages/users/_id.vue', name: 'users-id' &#125; ] &#125; ]&#125; Đừng quên include component trong component cha (.vue file) nhé ! MiddlewareMiddleware cho phép bạn định nghĩa một function trước khi hiển thị một trang hay một nhóm trang. Tất cả các middleware phải được đặt trong thư mục Middleware và tên file sẽ là tên của middleware. ví dụ (middleware/auth.js thì tên middleware sẽ là auth) Một middleware sẽ nhận 1 biến the context làm tham số đầu tiên. Ví dụ: 123export default function (context) &#123; context.userAgent = process.server ? context.req.headers['user-agent'] : navigator.userAgent&#125; Ở chế độ universal, thì middleware sẽ được gọi server-side một lần (Lần đâu tiên request đến nuxt app hoặc khi page được reload lại). với các lần điều hướng tiếp theo thì middleware được thực hiện ở client-side. Middleware sẽ được thực hiện theo thứ tự: nuxt.config.js Matched layouts Matched pages Kết luận Bài tiếp theo mình sẽ tìm hiểu về Views trong nuxtjs Tham khảohttps://nuxtjs.org/guide/routing","categories":[],"tags":[{"name":"vuejs","slug":"vuejs","permalink":"https://phamtuananh1996.github.io/tags/vuejs/"},{"name":"nuxtjs","slug":"nuxtjs","permalink":"https://phamtuananh1996.github.io/tags/nuxtjs/"}]},{"title":"Cài đặt và tìm hiểu cấu trúc thư mục của nuxtjs","slug":"cai-dat-va-tim-hieu-cau-truc-thu-muc-cua-nuxtjs","date":"2019-06-26T08:54:27.000Z","updated":"2020-05-27T06:18:16.086Z","comments":true,"path":"2019/06/26/cai-dat-va-tim-hieu-cau-truc-thu-muc-cua-nuxtjs/","link":"","permalink":"https://phamtuananh1996.github.io/2019/06/26/cai-dat-va-tim-hieu-cau-truc-thu-muc-cua-nuxtjs/","excerpt":"","text":"Giới thiệuNuxtjs là một framework sử dụng để xây dựng các ứng dụng từ Vue.js . Vì vậy điều kiện đầu tiên để tìm hiểu Nuxtjs là bạn phải tìm hiểu về vuejs trước.Một số tính năng nổi bật của Next.js: Mặc định đã được render phía server Tự động split code để load page nhanh hơn Đơn giản hóa routing phía client (page based) Môi trường dev với webpack-based hỗ trợ Hot Module Replacement (HMR) Có thể implement với Express hoặc những Node.js HTTP server khác Dễ dàng customize với Babel và Webpack configCài đặtĐể Cài đặt thì chúng ta có 2 cách : Dùng tool create-nuxt-app Dùng nxp Ở đây mình sẽ dùng nxp để cài đặt nuxtjs: 1$ npx create-nuxt-app &lt;project-name&gt; Hoặc qua yarn : 1$ yarn create nuxt-app &lt;project-name&gt; Trong quá trình cài đặt nó sẽ hỏi bạn 1 số thông tin như: Chọn server-side frameworks Chọn UI framework ưa thích của bạn Chọn testing framework Chế độ nuxt mà bạn muốn chọn ….. Sau khi chọn xong các thứ các thứ thì done. Để chạy được app chúng ta cd vào project sau đó chạy lệnh : 1npm run dev Sau khi chạy lệnh này xong thì mở trình duyệt và kiểm tra thành quả ở http://localhost:3000. Cấu trúc thư mụcAssets Directory Thư mục asset Chứa tài nguyên chưa được biên dịch như: Stylus hoặc Sass files, images, hoặc fontsComponents Directory Thư mục components chứa các file vuejs của bạn Layouts Directory Thư mục Layouts Chứa các layout (giao diện) cho ứng dụng Middleware Directory Thư mục Middleware Chức Middleware của ứng dụng, middleware cho phép bạn định nghĩa các function được chạy trước khi render 1 page hoặc nhóm page. Pages Directory Thư mục Pages Thư mục này chứa các view của ứng dụng cũng như định nghĩa routes cho ứng dụng. Plugins Directory Thư mục Plugins chức các plugin js Static Directory Thư mục statis Chứa các file tĩnh như các file ảnh chẳng hạn, được map tự động ví dụ file /static/logo.png sẽ là yoursite/logo.png Store Directory Thư mục store chứa các file vuex store nuxt.config.js File File nuxt.config.js Chứa các cấu hình được thiết đặt cho ứng dụng của bạn package.json File File package.json Quá quen thuộc rồi nó chứa các dependencies và scripts. Chú ý không được đổi tên file này Aliases ALIAS DIRECTORY ~ or @ srcDir ~~ or @@ rootDir Trong file vue template của bạn, nếu bạn cần link trong thư mục assets hoặc static chúng ta sẽ sử dụng ~/assets/yourimage.png và ~/static/your_image.png Mình xin tạm dừng bài viết ở đây. bài này mình đã giới thiệu cách cài đặt và giới thiệu qua câu trúc thư mục NUXT . Bài sau mình sẽ tìm hiểu về routing. cảm ơn các bạn đã đọc hết bài viết.Yêu hay không yêu xin để lại 1 comment ạ.","categories":[],"tags":[{"name":"vuejs","slug":"vuejs","permalink":"https://phamtuananh1996.github.io/tags/vuejs/"},{"name":"nuxtjs","slug":"nuxtjs","permalink":"https://phamtuananh1996.github.io/tags/nuxtjs/"}]},{"title":"Thay âm thanh tin nhắn Facebook bằng giọng của chị google với chưa đến 10 dòng code","slug":"thay-am-thanh-tin-nhan-facebook-bang-giong-cua-chi-google-voi-chua-den-10-dong-code","date":"2019-01-19T14:33:17.000Z","updated":"2020-05-27T06:21:28.215Z","comments":true,"path":"2019/01/19/thay-am-thanh-tin-nhan-facebook-bang-giong-cua-chi-google-voi-chua-den-10-dong-code/","link":"","permalink":"https://phamtuananh1996.github.io/2019/01/19/thay-am-thanh-tin-nhan-facebook-bang-giong-cua-chi-google-voi-chua-den-10-dong-code/","excerpt":"","text":"Nay lướt viblo Thấy bài https://viblo.asia/p/xay-dung-ung-dung-google-extension-don-gian-trong-10-phut-phan-1-RnB5pkrrlPG khá hay và mình khá hứng thú .vậy là mình bắt tay ngay vào viết 1 cái gì đó vui vui để thực hành ngay. Bài ToánMình muốn khi có ai đó nhắn tin cho mình thay vì tiếng báo tin nhắn như thường lệ mà mình muốn 1 âm thanh khác phát lên. Như video dưới đây .nhưng chỉ giống phần kết quả thôi nhé.còn cách làm hoàn toàn khác thanh niên trong video nhé. vì video mình lấy trên mạng. {@embed: https://www.youtube.com/watch?v=kHFZsUvgH-o} Hướng giải quyết Khi có tin nhắn thì chắc chắn Fb phải gửi 1 xhr lên để lấy thông tin của tin nhắn ấy =&gt; vậy mình cần phải tìm ra cái xhr đấy . Khi xhr được gửi đi thì mình sẽ chạy 1 đoạn script để phát âm thanh mà mình muốn =&gt; vậy mình cần 1 file âm thanh, và 1 đoạn script Muốn chạy được đoạn script ấy mình sẽ dùng chome extension. Giải quyếtvấn đề 1 : Khi có tin nhắn thì chắc chắn Fb phải gửi 1 xhr lên để lấy thông tin của tin nhắn ấy =&gt; vậy mình cần phải tìm ra cái xhr đấy Vấn đề này thì khá dễ ràng để tìm ra nhờ chrome developer tool của trình duyệt . sau 1 hồi mò mẫn thì mình đã tìm ra cái xhr ấy Vậy mình đã tim ra: https://www.facebook.com/ajax/mercury/delivery_receipts.php Mỗi lần có tin nhắn nó đề gửi cái này lên vấn đề 2 :Khi xhr được gửi đi thì mình sẽ chạy 1 đoạn script để phát âm thanh mà mình muốn =&gt; vậy mình cần 1 file âm thanh, và 1 đoạn script file âm thanh chị goole nói thì các bạn có thể truy cập https://translate.google.com/translate_tts?ie=UTF-8&amp;client=tw-ob&amp;q=am-thanh-muon-phat&amp;tl=vi&amp;total=1&amp;idx=0&amp;textlen=5 để tải xuống file âm thanh và thay âm thanh bạn muốn phát vào thôi. Đoạn scrip phát âm thanh thì chỉ cần đơn giản thế này thôi : var audio = new Audio(&apos;duong-dan-den-file-am-thanh.mp3&apos;); audio.play(); *Vấn đề 3 : Viết chome extension * Mình sẽ tạo ra 1 thư mục chứa 3 file : index.js =&gt; chứa đoạn script manifest.json =&gt; dùng để cấu hình cho extension notification.mp3 =&gt; file âm thanh Cấu hình file manifest.json12345678910&#123; \"name\": \"Google and facebook\", \"version\": \"1.0\", \"description\": \"Google and facebook!\", \"permissions\": [\"webRequest\",\"https://www.facebook.com/*\"], \"background\": &#123; \"scripts\": [\"index.js\"] &#125;, \"manifest_version\": 2&#125; permissions : ở đây mình xin quyền webRequest và mình chỉ sử dụng tiện ích này khi truy cập trang facebook các thông số khác chắc không phải giải thích gì thêm File index.js Ở đây mình sẽ dùng webRequest để theo dõi khi có tin nhắn dựa vào cái xhr mình vừa tìm được Các bạn có thể xem chi tiết: https://developer.chrome.com/extensions/webRequest Đây là ví dụ lắng nghe sự kiện onBeforeRequest : 12chrome.webRequest.onBeforeRequest.addListener( callback, filter, opt_extraInfoSpec); vậy callback sẽ là function để thực thi 1 hành động gì đó khi thỏa mãn cái filter kia. Ở ví dụ này thì cái callback sẽ là function phát âm thanh, filter sẽ là cái urls [“https://www.facebook.com/ajax/mercury/delivery_receipts.php*&quot;] Vậy mình ghép code file index.js như sau: 12345678chrome.webRequest.onBeforeRequest.addListener( function (details) &#123; var audio &#x3D; new Audio(&#39;notification.mp3&#39;); audio.play(); &#125;, &#123; urls: [&quot;https:&#x2F;&#x2F;www.facebook.com&#x2F;ajax&#x2F;mercury&#x2F;delivery_receipts.php*&quot;] &#125;); Vậy là xong : giờ mình đã có 1 thư mục chứa 3 file index.js, manifest.json, notification.mp3 . giờ mình chỉ việc import vào trình duyệt và test thành quả thôi. Để import vào trình duyệt bạn vào đường dẫn chrome://extensions/ bật chế độ nhà phát triển và tải lên tiện ích thì các b chỉ cần chọn đến thư mục chưa 3 file kia là ok . Kết luận: Vậy là xong giờ bạn vào facebook để xem thành quả thôi ! :) :100::joy: . Thành công hay không nhớ comment cho mình biết nhé !!! link github : https://github.com/phamtuananh1996/chome-extension","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://phamtuananh1996.github.io/tags/javascript/"},{"name":"extension","slug":"extension","permalink":"https://phamtuananh1996.github.io/tags/extension/"},{"name":"facebook","slug":"facebook","permalink":"https://phamtuananh1996.github.io/tags/facebook/"}]}],"categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://phamtuananh1996.github.io/tags/hexo/"},{"name":"laravel","slug":"laravel","permalink":"https://phamtuananh1996.github.io/tags/laravel/"},{"name":"javascript","slug":"javascript","permalink":"https://phamtuananh1996.github.io/tags/javascript/"},{"name":"extension","slug":"extension","permalink":"https://phamtuananh1996.github.io/tags/extension/"},{"name":"trick","slug":"trick","permalink":"https://phamtuananh1996.github.io/tags/trick/"},{"name":"vuejs","slug":"vuejs","permalink":"https://phamtuananh1996.github.io/tags/vuejs/"},{"name":"cookie","slug":"cookie","permalink":"https://phamtuananh1996.github.io/tags/cookie/"},{"name":"session","slug":"session","permalink":"https://phamtuananh1996.github.io/tags/session/"},{"name":"unit test","slug":"unit-test","permalink":"https://phamtuananh1996.github.io/tags/unit-test/"},{"name":"crud","slug":"crud","permalink":"https://phamtuananh1996.github.io/tags/crud/"},{"name":"nuxtjs","slug":"nuxtjs","permalink":"https://phamtuananh1996.github.io/tags/nuxtjs/"},{"name":"facebook","slug":"facebook","permalink":"https://phamtuananh1996.github.io/tags/facebook/"}]}